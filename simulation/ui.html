<script>

	/**
	 * An element that can be used for output and input of bit data.
	 * It can show 2 states 'ON' or 'OFF' indicated by colors.
	 * The element itself is a square with a border.
	 * Inside a number (or letter) can be shown, e.g. to indicate the bit index.
	 * If an 'onchange' function is given the element also observes the mouse
	 * to change it's internal state. (E.g. a mouse click to toggle the state.)
	 * Whenever a change happens the 'onchange' function is called.
	 *
	 * These values can be set inside the html tag on creation:
	 * - bitvalue: The initial value. Default is 0.
	 * - oncolor: The color used to indicate state 'ON', e.g. "red".
	 * - offcolor: The color used to indicate state 'OFF', e.g. "white".
	 * - onchange: If set the element is turned into an input element.
	 *     'onchange' is a function that is called when the state changes because of mouse activity.
	 * - togglemode: "true" (default) to toggle state on each mouse click.
	 *               "false" to set state to 'ON' only during button down.
	 *
	 * Examples:
	 * <ui-bit oncolor="green" offcolor="yellow"></ui-bit>
	 * <ui-bit togglemode="false" onchange="my_func(this)"></ui-bit>
	 * You can get the value (e.g. in 'my_func(this)' with 'this.bitvalue'.
	 */
	class UiBit extends HTMLElement {

		static get observedAttributes() {
			return ['bitvalue', 'oncolor', 'offcolor', 'togglemode', 'onchange'];
		}

		connectedCallback() {
			this.innerHTML = "";

			// Set default values.
			// https://www.w3schools.com/jsref/dom_obj_style.asp
			if(!this.style.margin)
				this.style.margin="0.0em";
			if (!this.style.padding)
				this.style.padding="0em";
			if (!this.style.textAlign)
				this.style.textAlign = "center";
			if (!this.style.display)
				this.style.display = "inline-block";
			if (!this.style.borderWidth)
				this.style.borderWidth = "thin";
			if (!this.style.borderStyle)
				this.style.borderStyle = "solid";
			if (!this.style.borderColor)
				this.style.borderColor = "black";
			if (!this.style.width)
				this.style.width = "1em";
			if (!this.style.height)
				this.style.height = "1em";
			if (!this.style.webkitUserSelect)
				this.style.webkitUserSelect = "none";
			if (!this.style.cursor)
				this.style.cursor = "pointer";

			// Init undefined
			if (this.bitvalue == undefined)
				this.bitvalue = 0;
			if (this.oncolor == undefined)
				this.oncolor = "red";
			if (this.offcolor == undefined)
				this.offcolor = "white";
			this.setColor();

			// Inform about initial value
			const bitvalue = this.bitvalue;
			this.bitvalue = undefined;	// To make sure it is different
			this.setBitValue(bitvalue);

			// Listeners for the mouse, depending on this.onstatechange
			this.registerMouseListeners();
		}


		attributeChangedCallback(name, oldValue, newValue) {
			if (name == "bitvalue") {
				this.bitvalue = newValue;
			}
			else if (name == "oncolor") {
				this.oncolor = newValue;
			}
			else if (name == "offcolor") {
				this.offcolor = newValue;
			}
			else if (name == "togglemode") {
				this.togglemode = (newValue == "true");
			}
			else if (name == "onchange") {
				// Note: this.onchange does not work
				this.onstatechange = eval("() => { " + newValue + " }");
			}
		}


		registerMouseListeners() {
			if (this.onstatechange != undefined)
			{
				this.style.cursor=`pointer`;
				if (this.togglemode == undefined)
					this.togglemode = true;
				this.addEventListener('click', () => {
					if (this.togglemode)
						this.toggle();
				});
				this.addEventListener('mousedown', () => {
					if (!this.togglemode)
						this.setBitValue(1);
				});
				this.addEventListener('mouseup', () => {
					if (!this.togglemode)
						this.setBitValue(0);
				});
				this.addEventListener('mouseleave', () => {
					if (!this.togglemode)
						this.setBitValue(0);
				});
			}
		}

		setBitIndex(index) {
			this.innerHTML = index;
		}

		setColor() {
			if (this.bitvalue != 0)
				this.style.backgroundColor = this.oncolor;
			else
				this.style.backgroundColor = this.offcolor;
		}

		setBitValue(newVal) {
			if (this.bitvalue != newVal) {
				this.bitvalue = newVal;
				// Check if someone waits on a notification
				if (this.onstatechange) {
					this.onstatechange();
				}
			}
			this.setColor();
		}

		toggle() {
			const newVal = (this.bitvalue == 0) ? 1 : 0;
			this.setBitValue(newVal);
		}
	}

	customElements.define('ui-bit', UiBit);


	/**
	 * Combines 8 UiBit elements into one.
	 *
	 * These values can be set inside the html tag on creation:
	 * - bytevalue: The initial value. Default is 0.
	 * - startindex: If set an index is shown in the bits. The indices start
	 *     at startindex.
	 * - oncolor: The color used to indicate state 'ON' of a bit, e.g. "red".
	 * - offcolor: The color used to indicate state 'OFF' of a bit, e.g. "white".
	 * - onchange: If set the element is turned into an input element.
	 *     'onchange' is a function that is called when the state changes because of mouse activity.
	 * - togglemode: "true" (default) to toggle state on each mouse click.
	 *               "false" to set state of a bit to 'ON' only during button down.
	 *
	 * Examples:
	 * <ui-byte oncolor="green" offcolor="yellow"></ui-byte>
	 * <ui-byte togglemode="false" onchange="my_func(this)"></ui-byte>
	 * You can get the value (e.g. in 'my_func(this)' with 'this.bytevalue'.
	 */
	class UiByte extends HTMLElement {

		static get observedAttributes() {
			return ['startindex', 'bytevalue', 'oncolor', 'offcolor', 'togglemode', 'onchange'];
		}

		connectedCallback() {
			this.innerHTML = "";
			if(!this.style.display)
				this.style.display = "inline-block";

			// Init undefined
			if (this.initialbytevalue == undefined)
				this.initialbytevalue = 0;
			if (this.oncolor == undefined)
				this.oncolor = "red";
			if (this.offcolor == undefined)
				this.offcolor = "white";
			if (this.togglemode == undefined)
				this.togglemode = true;

			// Create byte from bits
			this.bits = [];
			let k = this.startindex;
			if (k != undefined)
				k = 7 + parseInt(k);
			for (let i = 0; i < 8; i++) {
				const bit = document.createElement('ui-bit');
				// Togglemode
				bit.togglemode = this.togglemode;
				// Add object
				this.appendChild(bit);
				this.bits[i] = bit;
				// Bit index
				if (k != undefined) {
					bit.setBitIndex(k);
					k--;
				}
				// Color
				bit.oncolor = this.oncolor;
				bit.offcolor = this.offcolor;
				// Copy style (e.g. border-radius)
				bit.style.borderWidth = this.style.borderWidth;
				bit.style.borderRadius = this.style.borderRadius;
				bit.style.borderRadius = this.style.borderRadius;
				if (this.style.borderWidth)
					bit.style.borderWidth = this.style.borderWidth;
				if (this.style.borderStyle)
					bit.style.borderStyle = this.style.borderStyle;
				if (this.style.borderColor)
					bit.style.borderColor = this.style.borderColor;
			}

			// Set the value through setter. Send notification.
			this.bytevalue = this.initialbytevalue;

			// Set onchange
			for (let i = 0; i < 8; i++) {
				const bit = this.bits[i];
				// Onchange
				if (this.onstatechange) {
					bit.onstatechange = () => {
						this.onstatechange();
					};
					bit.registerMouseListeners();
				}
			}
		}


		attributeChangedCallback(name, oldValue, newValue) {
			if (name == "startindex") {
				this.startindex = newValue;
			}
			else if (name == "bytevalue") {
				this.initialbytevalue = parseInt(newValue);
			}
			else if (name == "oncolor") {
				this.oncolor = newValue;
			}
			else if (name == "offcolor") {
				this.offcolor = newValue;
			}
			else if (name == "togglemode") {
				this.togglemode = (newValue == "true");
			}
			else if (name == "onchange") {
				// Note: this.onchange does not work
				this.onstatechange = eval("() => { " + newValue + " }");
			}
		}

		// Get value
		get bytevalue() {
			let bitMaskIndex = 7;
			let value = 0;
			for (let i = 0; i < 8; i++) {
				const bit = this.bits[i];
				// Set value
				const bitvalue = bit.bitvalue;
				value += bit.bitvalue << bitMaskIndex;
				bitMaskIndex--;
			}
			return value;
		}

		// Set value
		set bytevalue(newVal) {
			let bitMaskIndex = 7;
			for (let i = 0; i < 8; i++) {
				const bit = this.bits[i];
				// Set value
				bit.bitvalue = (newVal >> bitMaskIndex) & 0x01;
				bitMaskIndex--;
				// Color
				bit.setColor();
			}
			// Notify
			if (this.onstatechange)
				this.onstatechange();
		}

	}

	customElements.define('ui-byte', UiByte);

// =================================



	function generate_interrupt(obj) {
		UIAPI.log("gen_int "+obj.bitvalue);
		// Only generate if value was changed to 1.
		if (obj.bitvalue != 0) {
			const msg = {
				command: 'generate_interrupt'
			};
			UIAPI.sendToCustomLogic(msg);
		}
	}

	function input_port(port, value) {
		const msg = {
			command: 'input_port',
			port: port,
			value: value
		};
		UIAPI.sendToCustomLogic(msg);
	}

	/**
	 * Handle the messages received from the custom logic.
	 */
	UIAPI.receivedFromCustomLogic = (msg) => {
		switch(msg.command) {
			case 'port_written':
				// Get the object for output
				const elem = document.getElementById("id_calc_result_"+msg.port.toString(16));
				// Set value
				elem.bytevalue = msg.value;
			break;
		}
	};

</script>

<table>

	<tr>
		<!-- UI for input of value1. -->
		<td style="text-align:right">Value1 =</td>
		<td>
			<ui-byte onchange="input_port(0x8000, this.bytevalue)"></ui-byte>
		</td>
	</tr>
	<tr>
		<!-- UI for input of value2. -->
		<td style="text-align:right">Value2 =</td>
		<td>
			<ui-byte onchange="input_port(0x8001, this.bytevalue)"></ui-byte>
		</td>
	</tr>

	<tr>
		<!-- UI to create an interrupt on mouse down event. -->
		<td style="text-align:right">Value1 + Value2 =</td>
		<td>
			<ui-byte id="id_calc_result_9000"></ui-byte>
		</td>
	</tr>

	<tr>
		<!-- UI to create an interrupt on mouse down event. -->
		<td style="text-align:right">Store (INT) :</td>
		<td>
			<!-- "border-radius" is used to make it a circle instead of a square -->
			<ui-bit style="border-radius:1em" togglemode="false" oncolor="yellow" onchange="generate_interrupt(this)"></ui-bit>
		</td>
	</tr>

	<tr>
		<!-- UI for output of stored result. -->
		<td style="text-align:right">Stored Value =</td>
		<td>
			<ui-byte oncolor="green" id="id_calc_result_9001"></ui-byte>
		</td>
	</tr>
</table>

